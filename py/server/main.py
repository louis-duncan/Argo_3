import socket
import time
from threading import Thread
import json
from queue import SimpleQueue
from .gameobject import *


class InvalidUpdateError(Exception):
    pass


class InvalidActionError(Exception):
    pass


class Clock:
    def __init__(self, tps):
        self.period = 1 / tps
        self.last_tick_time = 0

    def tick(self):
        tts = self.period - (time.time() - self.last_tick_time)
        if tts > 0:
            time.sleep(tts)


class Action:
    """Represents a game action. Refers to a single in game target object,
    gives the action, and the value (if required for that action)."""
    def __init__(self, source, seq, target, action, value, **kwargs):
        self.source: tuple = source  # Source address tuple: (addr, port).
        self.seq: int = seq  # Sequential number update number, generated by the clients.
        self.target: int = target  # Int id of the target of the action.
        self.action: str = action  # String action type.
        self.value = value  # Action value, indeterminate type.

    def __repr__(self):
        return f"Target: {self.target} > {self.action} - {self.value}"


class Client:
    """Represents a client connected to the server. Used to wrap an open socket.
    This object will run a receiving thread and present a method for getting received updates from its client.
    The prefix must be an int which has been generated and is known by the client on this socket."""
    def __init__(self, sock: socket.socket, prefix: int):
        self.open = True
        self.close_state = None
        self.socket = sock
        self.prefix = prefix
        self.updates_rx = SimpleQueue()

        self.receive_thread = Thread(target=self._receive_loop)
        self.receive_thread.start()

    def getpeername(self):
        return self.socket.getpeername()

    def close(self, state="Closed."):
        """Close the socket and mark the Client as closed."""
        self.open = False
        return self.socket.close()

    def _receive_loop(self):
        current_message = b""
        while self.open:
            try:
                b = self.socket.recv(1)
                if b == b"":
                    self.close("Client Closed Connection.")
                else:
                    # noinspection DuplicatedCode
                    if b == b"\0":
                        # Convert current message to an object and purge.
                        data = json.loads(current_message.decode())
                        current_message = b""

                        # Check all required keys exist.
                        if all(k in ("seq", "target", "action", "value") for k in data.keys()):
                            self.updates_rx.put(
                                Action(
                                    source=self.socket.getpeername(),
                                    **data
                                )
                            )
                        else:
                            raise InvalidUpdateError
                    else:
                        current_message += b  # Byte is not EOF and is not a terminator, so add to message.

            except (InvalidUpdateError, json.JSONDecodeError, ConnectionAbortedError, ConnectionError) as e:
                self.open = False
                if type(e) is InvalidUpdateError:
                    msg = "Client sent invalid update data."
                elif type(e) is json.JSONDecodeError:
                    msg = "Client sent invalid JSON data."
                elif type(e) is ConnectionAbortedError:
                    msg = "Socket closed by server."
                else:
                    msg = f"Connection Error. {e}."
                self.close(msg)
                print(f"Client {self.getpeername()} closed.")

    def send_update(self, update: Update):
        """Sends an update object to the client."""
        if self.socket.getpeername() == update.source:
            return 0
        else:
            data = {
                "seq": update.seq,
                "target": update.target,
                "action": update.action,
                "value": update.value
            }
            data = json.dumps(data).encode() + b"\0"
            print(f"Sending update {update} from {update.source} to {self.getpeername()}")
            return self.socket.send(data)


class Server:
    def __init__(self, address="0.0.0.0", port=8989, game=None):
        self.game = game
        self.run = True
        self.clients = []

        self.updates_rx = SimpleQueue()
        self.updates_tx = SimpleQueue()

        # Set up server socket.
        self.socket = socket.socket()
        self.socket.bind((address, port))
        self.socket.listen(5)

        # Start threads.
        self.connection_thread = Thread(target=self._connect_loop)
        self.connection_thread.start()

        self.rx_thread = Thread(target=self._rx_loop)
        self.rx_thread.start()

        self.tx_thread = Thread(target=self._tx_loop)
        self.tx_thread.start()

        self.event_handler_thread = Thread(target=self._process_actions)
        self.event_handler_thread.start()

    def _connect_loop(self):
        while self.run:
            new, addr = self.socket.accept()
            to_go = []
            for client in self.clients:
                if client.open:
                    try:
                        if client.getpeername() == addr:
                            to_go.append(client)
                    except OSError:
                        to_go.append(client)
                else:
                    to_go.append(client)
            for cs in to_go:
                self.clients.remove(cs)
            self.clients.append(Client(new))
            print(f"New client connected from {new.getpeername()}.")

    def _rx_loop(self):
        while self.run:
            client: Client
            for client in self.clients:
                for i in range(client.updates_rx.qsize()):
                    self.updates_rx.put(client.updates_rx.get())
            time.sleep(0.1)

    def _tx_loop(self):
        while self.run:
            while not self.updates_tx.empty():
                a: Action = self.updates_tx.get()
                for client in self.clients:
                    if a.source != client.getpeername():
                        client.send_update(a)
                time.sleep(0.1)
            time.sleep(0.1)

    def _process_actions(self):
        while self.run:
            while not self.updates_rx.empty():
                a: Action = self.updates_rx.get()
                if self.game is not None:
                    self.game.process_action(a)
                time.sleep(0.1)
            time.sleep(0.1)

    def pass_action(self, action: Action):
        self.updates_tx.put(action)


class Game:
    def __init__(self):
        """An instance of the game engine. Handles events and maintains the current state of the game."""
        self.run = True
        self.action_queue = SimpleQueue()
        self.game_loop_thread = Thread(
            target=self._game_loop
        )
        self.game_loop_thread.start()
        self.objects = {}

    def pass_action(self, action: Action):
        self.action_queue.put(action)

    def destroy_object(self, obj):
        pass

    def _game_loop(self):
        clock = Clock(15)
        while self.run:
            for i in range(self.action_queue.qsize()):
                a = self.action_queue.get()
                if a.target == -1:
                    # Denotes a game-wide action.
                    pass
                else:
                    # Action relates to a specific object in the game.
                    try:
                        obj: GameObject = self.objects[a.target]
                        obj.handle_action(a)
                    except KeyError:
                        print("Action for unknown object!")
                    except InvalidActionError:
                        print("Invalid action.")

            clock.tick()
